name: check-versions

on:
  schedule:
    # Run every Sunday at midnight UTC
    - cron: '0 0 * * 0'
  workflow_dispatch:

jobs:
  check-versions:
    name: Check for new upstream versions
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    steps:
      - uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2 https://github.com/actions/checkout/releases/tag/v6.0.2
        with:
          fetch-depth: 0

      - name: Download cardano-up
        run: |
          set -e
          curl -sLo cardano-up $(curl -s https://api.github.com/repos/blinklabs-io/cardano-up/releases/latest | grep "browser_download_url.*linux-amd64" | cut -d: -f2,3 | tr -d \")
          chmod +x cardano-up

      - name: Check and create PRs for new versions
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Read upstream config
          UPSTREAM_CONFIG="scripts/upstream-versions.json"

          # Get list of packages from config
          PACKAGES=$(jq -r 'keys[]' "$UPSTREAM_CONFIG")

          for PACKAGE in $PACKAGES; do
            echo "=========================================="
            echo "Checking package: $PACKAGE"
            echo "=========================================="

            # Get upstream config for this package
            REPO=$(jq -r --arg pkg "$PACKAGE" '.[$pkg].repo' "$UPSTREAM_CONFIG")
            TAG_PATTERN=$(jq -r --arg pkg "$PACKAGE" '.[$pkg].tag_pattern' "$UPSTREAM_CONFIG")
            VERSION_REGEX=$(jq -r --arg pkg "$PACKAGE" '.[$pkg].version_regex // ""' "$UPSTREAM_CONFIG")
            DOCKER_IMAGE=$(jq -r --arg pkg "$PACKAGE" '.[$pkg].docker_image // ""' "$UPSTREAM_CONFIG")
            GHCR_IMAGE=$(jq -r --arg pkg "$PACKAGE" '.[$pkg].ghcr_image // ""' "$UPSTREAM_CONFIG")

            echo "  Upstream repo: $REPO"
            echo "  Tag pattern: $TAG_PATTERN"

            # If ghcr_image is configured, use GHCR as the source of truth for versions
            # This is useful when the upstream repo uses different versioning than the container image
            if [[ -n "$GHCR_IMAGE" ]]; then
              echo "  Using GHCR image as version source: $GHCR_IMAGE"
              # Parse org and package name from ghcr_image (format: org/package)
              GHCR_ORG="${GHCR_IMAGE%%/*}"
              GHCR_PKG="${GHCR_IMAGE#*/}"

              # Query GHCR for tags, filter to semver-like versions, sort and get latest
              # Use --paginate to fetch all pages since the API returns paginated results
              UPSTREAM_VERSION=$(gh api "/orgs/${GHCR_ORG}/packages/container/${GHCR_PKG}/versions" --paginate \
                --jq '.[].metadata.container.tags[]' 2>/dev/null \
                | grep -E '^[0-9]+\.[0-9]+\.[0-9]+$' \
                | sort -V | tail -1 || echo "")

              if [[ -z "$UPSTREAM_VERSION" ]]; then
                echo "  WARNING: Could not fetch versions from GHCR for $GHCR_IMAGE, skipping"
                continue
              fi

              echo "  Latest GHCR version: $UPSTREAM_VERSION"
              # Set LATEST_TAG for PR body (no upstream release link for GHCR-sourced versions)
              LATEST_TAG=""
            else
              # Get latest upstream release tag
              LATEST_TAG=$(gh api "repos/${REPO}/releases/latest" --jq '.tag_name' 2>/dev/null || echo "")

              if [[ -z "$LATEST_TAG" ]]; then
                echo "  WARNING: Could not fetch latest release for $REPO, skipping"
                continue
              fi

              echo "  Latest upstream tag: $LATEST_TAG"

              # Extract version from tag
              if [[ -n "$VERSION_REGEX" ]]; then
                # Use custom regex to extract version
                UPSTREAM_VERSION=$(echo "$LATEST_TAG" | grep -oP "$VERSION_REGEX" | head -1 || echo "")
                if [[ -z "$UPSTREAM_VERSION" ]]; then
                  echo "  WARNING: Could not extract version using regex, skipping"
                  continue
                fi
                # For regex patterns that capture groups, extract the first group
                UPSTREAM_VERSION=$(echo "$LATEST_TAG" | sed -E "s/$VERSION_REGEX/\1/" || echo "$LATEST_TAG")
              elif [[ -n "$TAG_PATTERN" ]]; then
                # Remove tag pattern prefix
                UPSTREAM_VERSION="${LATEST_TAG#$TAG_PATTERN}"
              else
                # Use tag as-is
                UPSTREAM_VERSION="$LATEST_TAG"
              fi

              # If docker_image is configured, look up the actual image tag version
              # This handles cases where GitHub releases use short versions (v2.11)
              # but Docker images use full semver (v2.11.0)
              if [[ -n "$DOCKER_IMAGE" ]]; then
                echo "  Looking up Docker image tags for: $DOCKER_IMAGE"
                # Query Docker Hub for tags matching the release version
                DOCKER_TAG=$(curl -s "https://hub.docker.com/v2/repositories/${DOCKER_IMAGE}/tags?page_size=100" \
                  | jq -r --arg prefix "${TAG_PATTERN}${UPSTREAM_VERSION}" \
                    '.results[].name | select(startswith($prefix))' \
                  | sort -V | tail -1 || echo "")
                if [[ -n "$DOCKER_TAG" ]]; then
                  # Extract version from docker tag using same pattern
                  UPSTREAM_VERSION="${DOCKER_TAG#$TAG_PATTERN}"
                  echo "  Found Docker tag: $DOCKER_TAG -> version $UPSTREAM_VERSION"
                else
                  echo "  WARNING: No matching Docker tag found for ${TAG_PATTERN}${UPSTREAM_VERSION}"
                fi
              fi
            fi

            echo "  Upstream version: $UPSTREAM_VERSION"

            # Get latest local version
            LATEST_LOCAL_FILE=$(find "packages/${PACKAGE}" -maxdepth 1 -name "${PACKAGE}-*.yaml" -type f 2>/dev/null | sort -V | tail -1 || echo "")

            if [[ -z "$LATEST_LOCAL_FILE" ]]; then
              echo "  WARNING: No local version files found for $PACKAGE, skipping"
              continue
            fi

            LOCAL_VERSION=$(grep -E '^version:' "$LATEST_LOCAL_FILE" | head -1 | awk '{print $2}')
            echo "  Local version: $LOCAL_VERSION"

            # Compare versions (simple string comparison - may need improvement for complex version schemes)
            if [[ "$UPSTREAM_VERSION" == "$LOCAL_VERSION" ]]; then
              echo "  Already up to date"
              continue
            fi

            # Check if we already have this version
            NEW_FILE="packages/${PACKAGE}/${PACKAGE}-${UPSTREAM_VERSION}.yaml"
            if [[ -f "$NEW_FILE" ]]; then
              echo "  Version $UPSTREAM_VERSION already exists locally"
              continue
            fi

            echo "  New version available: $UPSTREAM_VERSION"

            # Check if a PR already exists for this version
            BRANCH_NAME="chore/${PACKAGE}-${UPSTREAM_VERSION}"
            EXISTING_PR=$(gh pr list --head "$BRANCH_NAME" --json number --jq '.[0].number' 2>/dev/null || echo "")
            if [[ -n "$EXISTING_PR" ]]; then
              echo "  PR #$EXISTING_PR already exists for this version, skipping"
              continue
            fi

            # Create new version
            echo "  Creating new version file..."
            ./scripts/add-version.sh "$PACKAGE" "$UPSTREAM_VERSION"

            # Validate the new package
            echo "  Validating new package..."
            if ! ./cardano-up validate -D 2>&1; then
              echo "  WARNING: Validation failed for $PACKAGE $UPSTREAM_VERSION, skipping"
              git checkout -- "packages/${PACKAGE}/" || true
              continue
            fi

            # Create branch and commit
            echo "  Creating branch and commit..."
            git checkout -b "$BRANCH_NAME"
            git add "packages/${PACKAGE}/${PACKAGE}-${UPSTREAM_VERSION}.yaml"
            git commit -m "chore: ${PACKAGE} ${UPSTREAM_VERSION}"

            # Push branch
            echo "  Pushing branch..."
            git push -u origin "$BRANCH_NAME"

            # Create PR
            echo "  Creating PR..."
            if [[ -n "$LATEST_TAG" ]]; then
              PR_BODY="## Summary
          - Updates ${PACKAGE} to version ${UPSTREAM_VERSION}
          - Upstream release: https://github.com/${REPO}/releases/tag/${LATEST_TAG}

          ## Test plan
          - [ ] CI validation passes
          - [ ] Manual testing if needed

          ðŸ¤– Generated automatically by check-versions workflow"
            else
              PR_BODY="## Summary
          - Updates ${PACKAGE} to version ${UPSTREAM_VERSION}
          - Source: ghcr.io/${GHCR_IMAGE}:${UPSTREAM_VERSION}

          ## Test plan
          - [ ] CI validation passes
          - [ ] Manual testing if needed

          ðŸ¤– Generated automatically by check-versions workflow"
            fi

            gh pr create \
              --title "chore: ${PACKAGE} ${UPSTREAM_VERSION}" \
              --body "$PR_BODY" \
              --base main \
              --head "$BRANCH_NAME"

            # Return to main branch for next package
            git checkout main

            echo "  PR created successfully!"
          done

          echo ""
          echo "=========================================="
          echo "Version check complete"
          echo "=========================================="
